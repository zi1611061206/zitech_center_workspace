{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Zi Coder Agent Documentation","text":"<p>Welcome to the documentation for Zi Coder Agent, a comprehensive toolset for coding assistance and automation.</p> <p>This documentation provides detailed information on the setup, usage, and architecture of the Zi Coder Agent project.</p>"},{"location":"active_context/","title":"Active Context for Zi Coder Agent","text":""},{"location":"active_context/#current-focus","title":"Current Focus","text":"<ul> <li>Documentation Completion: Finalizing a comprehensive documentation structure using MkDocs to ensure all project aspects are thoroughly detailed and accessible, providing a solid foundation for development and user onboarding.</li> </ul>"},{"location":"active_context/#active-decisions","title":"Active Decisions","text":"<ul> <li>MkDocs with Material Theme: Committed to using MkDocs with the Material theme for its modern, responsive design and user-friendly documentation interface, enhancing readability and navigation.</li> <li>Documentation Structure: Organizing documentation into logical categories (Project Overview, Setup, Usage, Project Management, Knowledge Base) to align with project modules and cater to diverse user needs, from developers to end-users.</li> <li>Content Depth: Prioritizing detailed, project-specific content over placeholder text in all core documentation files to ensure immediate utility and relevance.</li> </ul>"},{"location":"active_context/#recent-changes","title":"Recent Changes","text":"<ul> <li>Core Documentation Enhancement: Significantly updated key files including Product Requirement Document, Architecture, Technical Specifications, and Tasks Plan with detailed, project-specific information, moving beyond initial placeholders.</li> <li>Navigation Update: Fully configured the navigation structure in <code>mkdocs.yml</code> to include all documentation files, ensuring seamless access through the MkDocs site.</li> <li>Server Running: MkDocs development server is active at <code>http://127.0.0.1:8000/</code>, allowing real-time preview and review of documentation updates.</li> </ul>"},{"location":"active_context/#next-steps","title":"Next Steps","text":"<ul> <li>Documentation Review: Conduct a thorough review of remaining documentation files (<code>error-documentation.mdc</code>, <code>lessons-learned.mdc</code>) to expand content with practical examples and project-specific insights.</li> <li>API Development Kickoff: Begin detailed development and testing of API endpoints, focusing on integration with AI models for coding assistance, as outlined in the Tasks Plan.</li> <li>User Feedback Integration: Solicit initial user feedback on documentation usability and content completeness to identify gaps or areas for further clarification before advancing to deeper technical implementation.</li> </ul> <p>Note: This document will be updated regularly to reflect the evolving focus, active decisions, recent changes, and immediate next steps as the project progresses through its development lifecycle.</p>"},{"location":"architecture/","title":"Architecture of Zi Coder Agent","text":""},{"location":"architecture/#system-design","title":"System Design","text":"<p>Zi Coder Agent is engineered with a modular, microservices-oriented architecture to ensure scalability, maintainability, and flexibility. This design enables independent development, testing, and deployment of individual components while facilitating seamless integration to deliver AI-driven coding assistance.</p>"},{"location":"architecture/#component-relationships","title":"Component Relationships","text":"<ul> <li>API Server: Built with Flask, this serves as the central interface for user interactions, handling HTTP requests, and providing access to the Swagger UI for API documentation and testing. It routes user requests to appropriate backend services.</li> <li>Database: Utilizes SQLAlchemy as an ORM layer and Alembic for migrations, managing persistent storage for configurations, AI model metadata, user data, and task history. It supports SQLite for development and PostgreSQL for production environments.</li> <li>Model Management: Manages the lifecycle of AI models, including loading, unloading, and updating models for code generation and analysis. This component ensures the right model is available for specific tasks based on user requirements or project context.</li> <li>MCP Server Management: Coordinates connections to Model Context Protocol (MCP) servers, enabling extended capabilities such as accessing external tools and resources. It handles communication protocols and ensures secure integration with third-party services.</li> <li>Cache Management: Leverages Redis to cache frequently accessed data like model outputs, API responses, and user session information, significantly improving response times and reducing computational overhead.</li> <li>Worker Management: Employs Celery for distributed task processing, managing background tasks such as long-running AI computations or batch operations. Workers operate asynchronously, ensuring the API remains responsive during intensive tasks.</li> </ul>"},{"location":"architecture/#data-flow","title":"Data Flow","text":"<ul> <li>User Request: A user interacts with the API Server through HTTP requests, initiating tasks like code generation or debugging.</li> <li>Task Dispatch: The API Server routes the task to the appropriate component, such as Model Management for AI processing, often delegating intensive tasks to Workers via Celery.</li> <li>Data Access: Components interact with the Database for persistent storage or retrieve cached data from Redis to optimize performance.</li> <li>External Integration: MCP Server Management facilitates connections to external services or tools as needed, expanding the agent's capabilities.</li> <li>Response: Results are processed, cached if necessary, and returned to the user via the API Server, often with detailed feedback or generated code.</li> </ul>"},{"location":"architecture/#dependencies","title":"Dependencies","text":"<ul> <li>Core Framework: The system relies on Python 3.9+ for core functionality, with dependencies managed via <code>pyproject.toml</code> and installed through <code>uv</code> or <code>pip</code> as detailed in <code>requirements.txt</code>.</li> <li>Web Serving: Flask provides the web framework for the API Server, with <code>flask-swagger-ui</code> integrating interactive API documentation.</li> <li>Database Management: SQLAlchemy handles ORM operations, while Alembic manages schema migrations, and <code>pymysql</code> supports MySQL connections if needed.</li> <li>Task Queue and Caching: Celery orchestrates asynchronous task execution, and Redis serves as an in-memory store for caching and message brokering.</li> <li>Development Tools: Development dependencies include <code>pytest</code> for testing, <code>black</code> and <code>isort</code> for code formatting, and <code>pylint</code> and <code>flake8</code> for linting, ensuring code quality.</li> </ul>"},{"location":"architecture/#architectural-diagram","title":"Architectural Diagram","text":"<p>Below is a simplified representation of the system architecture using Mermaid for visualization:</p> <pre><code>graph TD\n    U[User] --&gt;|HTTP Request| API[API Server - Flask]\n    API --&gt;|Routes Task| MM[Model Management]\n    API --&gt;|Routes Task| MCP[MCP Server Management]\n    API --&gt;|Routes Task| CM[Cache Management - Redis]\n    API --&gt;|Delegates Task| WM[Worker Management - Celery]\n    WM --&gt;|Processes| MM\n    WM --&gt;|Processes| MCP\n    MM --&gt;|Accesses| DB[Database - SQLAlchemy/Alembic]\n    CM --&gt;|Stores/Retrieves| DB\n    MCP --&gt;|Connects| EXT[External MCP Servers]\n    DB --&gt;|Persists| DATA[Data Storage]\n    CM --&gt;|Caches| DATA\n    API --&gt;|Returns Response| U\n</code></pre>"},{"location":"architecture/#design-principles","title":"Design Principles","text":"<ul> <li>Modularity: Each component is designed to be independent, allowing for updates or replacements without affecting the entire system.</li> <li>Scalability: Horizontal scaling is supported through distributed workers and caching mechanisms to handle increased load.</li> <li>Extensibility: The MCP integration allows for plugging in new tools and services, ensuring the system can evolve with technological advancements.</li> <li>Performance: Asynchronous processing and caching are prioritized to minimize latency in user interactions.</li> <li>Maintainability: Clear separation of concerns and comprehensive documentation facilitate ongoing maintenance and onboarding of new developers.</li> </ul> <p>Note: This document will be further expanded with detailed sequence diagrams, additional component interactions, and specific dependency mappings as the project progresses.</p>"},{"location":"building_and_deploying/","title":"Building and Deploying Zi Coder Agent Documentation","text":""},{"location":"building_and_deploying/#building-the-documentation","title":"Building the Documentation","text":"<p>To build the documentation site for deployment, use the following command from the <code>zi_coder_agent</code> directory:</p> <pre><code>python -m mkdocs build\n</code></pre> <p>This will generate the static site in the <code>site</code> directory, which can be hosted on any static web server.</p>"},{"location":"building_and_deploying/#running-the-development-server","title":"Running the Development Server","text":"<p>To preview the documentation locally during development, run:</p> <pre><code>python -m mkdocs serve\n</code></pre> <p>This starts a local server at <code>http://127.0.0.1:8000/</code> where you can view the documentation in real-time with automatic reloading on file changes.</p>"},{"location":"building_and_deploying/#deploying-to-github-pages","title":"Deploying to GitHub Pages","text":"<p>If you wish to deploy the documentation to GitHub Pages, ensure your repository is set up with a <code>gh-pages</code> branch. Then, use the following command:</p> <pre><code>python -m mkdocs gh-deploy\n</code></pre> <p>This command builds the site and pushes it to the <code>gh-pages</code> branch of your repository, making it available at <code>https://&lt;username&gt;.github.io/&lt;repository-name&gt;/</code>.</p> <p>Note: Ensure that the <code>repo_url</code> in <code>mkdocs.yml</code> is correctly set to your repository URL for proper deployment configuration.</p>"},{"location":"building_and_deploying/#custom-deployment","title":"Custom Deployment","text":"<p>For deployment to other hosting services, build the site using the <code>build</code> command and upload the contents of the <code>site</code> directory to your hosting provider.</p> <p>Note: This document provides basic instructions for building and deploying the documentation. Additional configurations or steps may be required based on specific hosting environments or project needs.</p>"},{"location":"placeholder/","title":"ZiCoder Agent Documentation","text":"<p>This directory will contain detailed documentation for the ZiCoder Agent project, including architecture, technical specifications, and product requirement documents.</p>"},{"location":"placeholder/#placeholder","title":"Placeholder","text":"<p>This is a placeholder file. Actual documentation will be added as the project progresses.</p>"},{"location":"product_requirement_docs/","title":"Product Requirement Document (PRD) for Zi Coder Agent","text":""},{"location":"product_requirement_docs/#purpose","title":"Purpose","text":"<p>Zi Coder Agent is designed to revolutionize the coding experience by providing AI-driven assistance, enhancing developer productivity, and streamlining workflow efficiency through intelligent automation and context-aware suggestions.</p>"},{"location":"product_requirement_docs/#core-requirements","title":"Core Requirements","text":"<ul> <li>AI Assistance: Integration of advanced AI models to support code generation, debugging, optimization, and automated testing, tailored to various programming languages and frameworks.</li> <li>Modular Architecture: Implementation of a modular system with distinct components for model management, MCP server management, cache management, worker management, database interactions, and API services to ensure flexibility and maintainability.</li> <li>User Interface: Development of a user-friendly web-based interface using Flask and Swagger UI for seamless interaction with the agent, allowing users to manage tasks, view API documentation, and test endpoints directly.</li> <li>Scalability: Design the system to handle multiple concurrent tasks, scale with user demand, and support distributed processing using tools like Celery and Redis for task queuing and caching.</li> <li>Database Integration: Utilize SQLAlchemy and Alembic for robust database management and migrations, supporting SQLite and PostgreSQL for data persistence.</li> <li>Environment Compatibility: Ensure the agent operates across Windows, macOS, and Linux environments with setup instructions for virtual environments using both <code>uv</code> and <code>pip</code>.</li> </ul>"},{"location":"product_requirement_docs/#goals","title":"Goals","text":"<ul> <li>Automation: Streamline development processes by automating repetitive tasks such as code formatting, dependency management, and testing.</li> <li>Accuracy and Context: Provide highly accurate, context-aware coding suggestions by leveraging AI models trained on diverse codebases, adapting to project-specific patterns and user preferences.</li> <li>Compatibility and Integration: Ensure compatibility with various development environments and IDEs like VSCode, and integrate with existing tools and workflows through extensible APIs.</li> <li>Documentation and Support: Offer comprehensive documentation for setup, usage, and troubleshooting, alongside a knowledge base for error resolution and lessons learned to support continuous improvement.</li> </ul>"},{"location":"product_requirement_docs/#target-audience","title":"Target Audience","text":"<ul> <li>Developers: Individual developers and teams seeking to enhance productivity through AI assistance in coding tasks.</li> <li>Enterprises: Organizations looking to integrate AI-driven coding tools into their development pipelines for efficiency gains.</li> <li>Educators and Students: Academic users who can benefit from AI assistance in learning and practicing coding skills.</li> </ul>"},{"location":"product_requirement_docs/#use-cases","title":"Use Cases","text":"<ul> <li>Code Generation: Automatically generate boilerplate code, functions, or entire modules based on user prompts or project context.</li> <li>Debugging Support: Identify bugs, suggest fixes, and provide explanations for issues in the codebase.</li> <li>Optimization: Recommend performance improvements and refactoring opportunities to enhance code quality.</li> <li>Learning Tool: Assist in learning new programming languages or frameworks by providing real-time guidance and examples.</li> </ul>"},{"location":"product_requirement_docs/#constraints","title":"Constraints","text":"<ul> <li>Performance: Must handle large codebases and multiple simultaneous requests without significant latency.</li> <li>Security: Ensure user data and code are protected with appropriate security measures in API interactions and data storage.</li> <li>Resource Usage: Optimize resource consumption to run efficiently on standard developer hardware.</li> </ul> <p>Note: This document will be further refined with user feedback, detailed feature specifications, and prioritization of requirements as the project progresses.</p>"},{"location":"running_the_server/","title":"Running the Zi Coder Agent Server","text":"<p>This guide provides instructions for running the <code>zi-coder-agent</code> server and accessing the API documentation via Swagger UI.</p>"},{"location":"running_the_server/#prerequisites","title":"Prerequisites","text":"<ul> <li>Virtual Environment: Ensure you have set up a virtual environment and installed the dependencies as described in Virtual Environment Setup.</li> </ul>"},{"location":"running_the_server/#starting-the-server","title":"Starting the Server","text":"<ol> <li> <p>Activate the Virtual Environment:    If you haven't already activated your virtual environment, do so now:</p> </li> <li> <p>On Windows:      <code>bash      .venv\\Scripts\\activate</code></p> </li> <li> <p>On macOS/Linux:      <code>bash      source .venv/bin/activate</code></p> </li> <li> <p>Run the Server:    Use the provided <code>run_server.py</code> script to start the Flask server:</p> </li> </ol> <p><code>bash    python run_server.py</code></p> <p>By default, the server will run on <code>http://127.0.0.1:5000/</code>. You should see output in your terminal indicating that the server is running.</p>"},{"location":"running_the_server/#accessing-the-swagger-ui","title":"Accessing the Swagger UI","text":"<p>The <code>zi-coder-agent</code> API provides a Swagger UI for interactive API documentation. Once the server is running, you can access the Swagger UI at:</p> <p>http://127.0.0.1:5000/swagger</p> <p>This interface allows you to explore the API endpoints, view their documentation, and even test API calls directly from the browser.</p>"},{"location":"running_the_server/#stopping-the-server","title":"Stopping the Server","text":"<p>To stop the server, simply press <code>Ctrl+C</code> in the terminal where the server is running. This will terminate the Flask application.</p>"},{"location":"running_the_server/#additional-notes","title":"Additional Notes","text":"<ul> <li>Server Configuration: If you need to change the host or port, you can modify the <code>run_server.py</code> script or pass arguments when running the script. Check the script for more details on configuration options.</li> <li>Troubleshooting: If you encounter issues, ensure all dependencies are installed correctly and that no other application is using the port (default is 5000).</li> </ul> <p>By following these steps, you can easily run the <code>zi-coder-agent</code> server and interact with its API through the Swagger UI.</p>"},{"location":"tasks_plan/","title":"Tasks Plan for Zi Coder Agent","text":""},{"location":"tasks_plan/#current-tasks","title":"Current Tasks","text":"<ul> <li>Setup Documentation: Establish comprehensive project documentation using MkDocs, ensuring all core files are detailed and accessible through the navigation structure.</li> <li>API Development: Enhance API endpoints for better integration and functionality, focusing on user interaction with AI assistance features.</li> <li>Model Integration: Integrate new AI models for improved coding assistance, including support for code generation, debugging, and optimization.</li> <li>Database Optimization: Refine database schemas and migration scripts using SQLAlchemy and Alembic to support scalability and data management needs.</li> <li>Caching Implementation: Implement and test Redis-based caching strategies to optimize API response times and reduce load on AI models.</li> <li>Worker Task Management: Develop and test Celery configurations for asynchronous task processing, ensuring efficient handling of long-running operations.</li> <li>MCP Server Connectivity: Establish secure and reliable connections to external MCP servers for extended tool and resource access.</li> </ul>"},{"location":"tasks_plan/#project-progress","title":"Project Progress","text":"<ul> <li>Documentation: Setup is advanced with core files like Product Requirement Document, Architecture, and Technical Specifications now detailed. Navigation structure in MkDocs is fully updated to include all documentation.</li> <li>Server Setup: Initial server setup and virtual environment configurations are documented and operational, with Flask server running and Swagger UI accessible.</li> <li>API Structure: Basic API endpoints are defined in the codebase, with ongoing enhancements for AI integration.</li> <li>Testing Framework: Initial setup for testing with <code>pytest</code> is in place, with test scripts for API server, database, and management components created.</li> </ul>"},{"location":"tasks_plan/#current-status","title":"Current Status","text":"<ul> <li>The project is progressing through the foundational setup phase, with a strong focus on comprehensive documentation to ensure clarity for future development stages. API and model integration are the next priorities, building on the established environment and server configurations.</li> </ul>"},{"location":"tasks_plan/#known-issues","title":"Known Issues","text":"<ul> <li>Documentation Depth: Some documentation files still contain placeholder content in sections that require further technical detail or project-specific examples.</li> <li>Model Integration Delays: Integration of AI models is pending detailed specification of supported frameworks and performance benchmarks.</li> <li>Scalability Testing: Full testing of scalability features with Celery and Redis under high load has not yet been conducted, which may reveal performance bottlenecks.</li> <li>Security Protocols: Detailed security measures for API interactions and MCP server communications need to be finalized and documented.</li> </ul>"},{"location":"tasks_plan/#timeline-and-milestones","title":"Timeline and Milestones","text":"<ul> <li>Week 1-2: Complete detailed documentation for all core project aspects, ensuring no placeholder content remains.</li> <li>Week 3-4: Finalize API endpoint development with full Swagger documentation and initial user testing.</li> <li>Week 5-6: Integrate and test primary AI models for coding assistance, establishing baseline performance metrics.</li> <li>Week 7-8: Implement and stress-test caching and worker management systems, optimizing for concurrent task handling.</li> <li>Week 9-10: Secure MCP server integrations with documented protocols and conduct security audits of API interactions.</li> <li>End of Month 3: Achieve a stable beta release with core functionalities operational, comprehensive documentation, and initial user feedback incorporated.</li> </ul> <p>Note: This document will be regularly updated with detailed task breakdowns, revised timelines, and progress tracking as the project advances. Adjustments to priorities and timelines will be made based on development challenges and user feedback.</p>"},{"location":"technical/","title":"Technical Specifications for Zi Coder Agent","text":""},{"location":"technical/#development-environment","title":"Development Environment","text":"<ul> <li>Language: Python 3.9+ is required to ensure compatibility with modern libraries and features used in the project.</li> <li>IDE Support: Optimized for Visual Studio Code with extensions for Python, Git, and Markdown, but compatible with other major IDEs like PyCharm and IntelliJ IDEA.</li> <li>Version Control: Git for source code management, hosted on platforms like GitHub for collaboration and version tracking.</li> <li>Dependency Management: Supports both <code>uv</code> for fast dependency resolution and <code>pip</code> for traditional package installation, managed via <code>pyproject.toml</code>.</li> <li>Virtual Environment: Utilizes isolated environments (<code>.venv</code>) to prevent dependency conflicts and ensure reproducibility across development setups.</li> </ul>"},{"location":"technical/#technologies-used","title":"Technologies Used","text":"<ul> <li>Web Framework: Flask as the lightweight WSGI framework for building the API server, chosen for its simplicity and flexibility in rapid development.</li> <li>API Documentation: <code>flask-swagger-ui</code> for integrating Swagger UI, providing interactive documentation and testing capabilities for API endpoints.</li> <li>Database: SQLAlchemy as the ORM for database interactions, with Alembic for schema migrations, supporting SQLite for development and PostgreSQL for production environments.</li> <li>Task Queue: Celery for distributed task processing, enabling asynchronous execution of long-running AI tasks or batch operations.</li> <li>Caching: Redis as an in-memory data store for caching API responses, model outputs, and session data to enhance performance.</li> <li>AI Models: Infrastructure to integrate with machine learning frameworks and external MCP servers for AI capabilities, managed through the Model Management component.</li> <li>Testing: <code>pytest</code> for unit and integration testing, with <code>pytest-cov</code> for coverage analysis to ensure code reliability.</li> <li>Code Quality: Tools like <code>black</code> and <code>isort</code> for formatting, <code>pylint</code> and <code>flake8</code> for linting, and <code>pre-commit</code> hooks for maintaining code standards during development.</li> </ul>"},{"location":"technical/#key-technical-decisions","title":"Key Technical Decisions","text":"<ul> <li>Flask over FastAPI: Chose Flask for its simplicity and extensive community support, prioritizing ease of setup over the asynchronous benefits of FastAPI for the initial implementation, with potential migration planned for future scalability needs.</li> <li>Modular Design: Adopted a modular architecture to separate concerns (API, database, model management, etc.), improving maintainability and allowing independent updates to components.</li> <li>Redis for Caching: Selected Redis for its high performance in caching frequently accessed data, reducing load on the database and AI models, thus improving response times.</li> <li>Celery for Asynchronous Tasks: Implemented Celery with Redis as a message broker to handle computationally intensive tasks asynchronously, ensuring the API remains responsive under load.</li> <li>SQLAlchemy with Alembic: Opted for SQLAlchemy for its robust ORM capabilities and Alembic for database migrations, providing flexibility to switch between SQLite and PostgreSQL based on environment needs.</li> <li>Cross-Platform Support: Designed the system to be compatible with Windows, macOS, and Linux, using platform-agnostic tools and providing detailed setup instructions for each OS.</li> </ul>"},{"location":"technical/#constraints","title":"Constraints","text":"<ul> <li>Cross-Platform Compatibility: Must support Windows, macOS, and Linux environments, requiring careful handling of OS-specific paths, commands, and dependencies during setup and operation.</li> <li>Performance Requirements: Needs to efficiently process large codebases and handle multiple simultaneous requests with minimal latency, necessitating optimized caching and asynchronous processing.</li> <li>Resource Limitations: Should operate within the constraints of standard developer hardware (e.g., 8GB RAM, mid-range CPU), balancing AI model complexity with resource consumption.</li> <li>Security Considerations: Must protect user data and code through secure API interactions, encrypted database storage, and safe handling of external MCP server communications.</li> <li>Dependency Conflicts: Careful management of library versions in <code>pyproject.toml</code> to avoid conflicts, especially between development and production dependencies.</li> </ul>"},{"location":"technical/#setup-instructions","title":"Setup Instructions","text":"<ul> <li>Environment Setup: Detailed in <code>virtual_environment_setup.md</code>, covering virtual environment creation and dependency installation using <code>uv</code> or <code>pip</code>.</li> <li>Server Operation: Instructions for running the server are provided in <code>running_the_server.md</code>, including activation of the virtual environment and launching the Flask application.</li> <li>Documentation Deployment: Guidance on building and deploying the documentation site is available in <code>building_and_deploying.md</code>, supporting local previews and hosting on platforms like GitHub Pages.</li> </ul> <p>Note: This document will be further expanded with additional technical details, performance benchmarks, and specific setup configurations as the project progresses.</p>"},{"location":"virtual_environment_setup/","title":"Virtual Environment Setup for zi-coder-agent","text":"<p>This guide provides instructions for setting up a virtual environment for the <code>zi-coder-agent</code> project using either <code>uv</code> (a modern Python package manager designed for speed and simplicity) or <code>pip</code> (the standard Python package manager). By following these instructions, you ensure that your development environment is properly isolated and configured with all necessary dependencies.</p>"},{"location":"virtual_environment_setup/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.9+: Ensure you have Python 3.9 or higher installed on your system.</li> <li>UV (Optional): If you choose to use <code>uv</code>, install it if you haven't already. You can install it via pip or follow the instructions on the official UV GitHub page.</li> </ul> <p><code>bash   pip install uv</code></p> <ul> <li>Pip: <code>pip</code> comes bundled with Python, so no additional installation is required if Python is installed.</li> </ul>"},{"location":"virtual_environment_setup/#setting-up-the-virtual-environment","title":"Setting Up the Virtual Environment","text":""},{"location":"virtual_environment_setup/#option-1-using-uv","title":"Option 1: Using UV","text":"<ol> <li>Clone the Repository (if not already done):</li> </ol> <p><code>bash    git clone &lt;repository-url&gt;    cd zi-coder-agent</code></p> <ol> <li>Create a Virtual Environment with UV:</li> </ol> <p>Use <code>uv</code> to create a virtual environment. This will isolate project dependencies from your global Python environment.</p> <p><code>bash    uv venv</code></p> <p>This command creates a virtual environment in the <code>.venv</code> directory within the project root.</p> <ol> <li> <p>Activate the Virtual Environment:</p> </li> <li> <p>On Windows:      <code>bash      .venv\\Scripts\\activate</code></p> </li> <li>On macOS/Linux:      <code>bash      source .venv/bin/activate</code></li> </ol> <p>Once activated, your terminal prompt should change to indicate that the virtual environment is active.</p> <ol> <li>Install Dependencies:</li> </ol> <p>Use <code>uv</code> to install the project dependencies as defined in <code>pyproject.toml</code>.</p> <p><code>bash    uv sync</code></p> <p>This command installs all dependencies (both regular and dev-dependencies) specified under <code>[project.dependencies]</code> and <code>[project.optional-dependencies.dev]</code> in <code>pyproject.toml</code>.</p> <ol> <li>Verify Installation:</li> </ol> <p>You can verify that the dependencies were installed correctly by checking the virtual environment's site-packages or by running:</p> <p><code>bash    uv pip list</code></p>"},{"location":"virtual_environment_setup/#option-2-using-pip","title":"Option 2: Using Pip","text":"<ol> <li>Clone the Repository (if not already done):</li> </ol> <p><code>bash    git clone &lt;repository-url&gt;    cd zi-coder-agent</code></p> <ol> <li>Create a Virtual Environment with Pip:</li> </ol> <p>Use Python's built-in <code>venv</code> module to create a virtual environment.</p> <p><code>bash    python -m venv .venv</code></p> <p>This command creates a virtual environment in the <code>.venv</code> directory within the project root.</p> <ol> <li> <p>Activate the Virtual Environment:</p> </li> <li> <p>On Windows:      <code>bash      .venv\\Scripts\\activate</code></p> </li> <li>On macOS/Linux:      <code>bash      source .venv/bin/activate</code></li> </ol> <p>Once activated, your terminal prompt should change to indicate that the virtual environment is active.</p> <ol> <li>Install Dependencies:</li> </ol> <p>Use <code>pip</code> to install the project dependencies using the provided requirements files. These files list all necessary dependencies as defined in <code>pyproject.toml</code>, making installation straightforward.</p> <p>Install the main project dependencies:</p> <p><code>bash    pip install -r requirements.txt</code></p> <p>Optionally, install development dependencies (for testing, linting, etc.):</p> <p><code>bash    pip install -r requirements-dev.txt</code></p> <ol> <li>Verify Installation:</li> </ol> <p>You can verify that the dependencies were installed correctly by running:</p> <p><code>bash    pip list</code></p>"},{"location":"virtual_environment_setup/#deactivating-the-virtual-environment","title":"Deactivating the Virtual Environment","text":"<p>When you're done working on the project, you can deactivate the virtual environment:</p> <pre><code>deactivate\n</code></pre> <p>This will return you to your global Python environment.</p>"},{"location":"virtual_environment_setup/#dependency-information","title":"Dependency Information","text":"<p>Below is a comprehensive list of dependencies for the <code>zi-coder-agent</code> project as defined in <code>pyproject.toml</code>. This includes both main project dependencies and optional development dependencies.</p>"},{"location":"virtual_environment_setup/#main-dependencies","title":"Main Dependencies","text":"<p>These are required for the core functionality of the <code>zi-coder-agent</code> project:</p> <ul> <li>Flask (&gt;=2.0.1): A lightweight WSGI web application framework for building web applications.</li> <li>SQLAlchemy (&gt;=1.4.41): A SQL toolkit and Object-Relational Mapping (ORM) library for database interactions.</li> <li>Alembic (&gt;=1.8.1): A lightweight database migration tool for use with SQLAlchemy.</li> <li>redis (&gt;=4.0.2): A client for interacting with Redis, an in-memory data structure store used for caching.</li> <li>celery (&gt;=5.2.7): A distributed task queue for handling asynchronous tasks and workers.</li> <li>pymysql (&gt;=1.0.2): A pure-Python MySQL client library for database connections.</li> <li>flask-swagger-ui (&gt;=4.11.1): A Flask extension for integrating Swagger UI to document API endpoints.</li> </ul>"},{"location":"virtual_environment_setup/#development-dependencies","title":"Development Dependencies","text":"<p>These are optional and used for development, testing, and code quality assurance:</p> <ul> <li>pytest (&gt;=7.1.2): A testing framework for writing simple and scalable test cases.</li> <li>pytest-cov (&gt;=4.0.0): A pytest plugin for measuring code coverage.</li> <li>black (&gt;=22.10.0): An uncompromising code formatter for Python.</li> <li>isort (&gt;=5.10.1): A utility for sorting imports alphabetically and automatically separating them into sections.</li> <li>pylint (&gt;=2.15.5): A static code analysis tool for identifying errors and enforcing coding standards.</li> <li>flake8 (&gt;=5.0.4): A tool for style guide enforcement and linting.</li> <li>ruff (&gt;=0.0.292): A fast Python linter, written in Rust.</li> <li>djlint (&gt;=1.19.7): A linter for Django templates.</li> <li>yamllint (&gt;=1.28.0): A linter for YAML files.</li> <li>pre-commit (&gt;=2.20.0): A framework for managing and maintaining multi-language pre-commit hooks.</li> </ul>"},{"location":"virtual_environment_setup/#additional-notes","title":"Additional Notes","text":"<ul> <li>Updating Dependencies: </li> <li>With <code>uv</code>, if <code>pyproject.toml</code> is updated with new dependencies, run <code>uv sync</code> again to ensure your virtual environment is up-to-date.</li> <li>With <code>pip</code>, manually install any new dependencies listed in <code>pyproject.toml</code> or updates to existing ones using <code>pip install</code>.</li> <li>Project Structure: The virtual environment is located in <code>.venv</code> at the root of the project directory, keeping it separate from the source code and other project files.</li> <li>UV Documentation: For more advanced usage of <code>uv</code>, refer to the official documentation at https://github.com/astral-sh/uv.</li> <li>Pip Documentation: For more information on using <code>pip</code> and virtual environments, refer to the official Python documentation at https://docs.python.org/3/library/venv.html.</li> </ul> <p>By following these steps, you ensure that your development environment for <code>zi-coder-agent</code> is properly isolated and configured with all necessary dependencies, whether using <code>uv</code> or <code>pip</code>.</p>"}]}